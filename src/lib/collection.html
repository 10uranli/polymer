<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="debounce.html">

<script>

  Polymer._collections = new WeakMap();

  Polymer.Collection = function(userArray) {
    Polymer._collections.set(userArray, this);
    this.userArray = userArray;
    this.initStore();
  };

  Polymer.Collection.prototype = {

    constructor: Polymer.Collection,

    _primitiveTypes: {
      'string': String,
      'number': Number,
      'boolean': Boolean
    },

    initStore: function() {
      var map = this.map = new WeakMap();
      for (var i=0; i<this.userArray.length; i++) {
        map.set(this.ensureUniqueItem(i), i);
      }
      this.store = this.userArray.slice();
    },

    add: function(item) {
      var key = this.store.push(item) - 1;
      this.map.set(item, key);
      return key;
    },

    removeKey: function(key) {
      this.map.delete(this.store[key]);
      delete this.store[key];
    },

    remove: function(item) {
      var key = this.getKey(item);
      this.removeKey(key);
      return key;
    },

    getKey: function(item) {
      return this.map.get(item);
    },

    getKeys: function() {
      return Object.keys(this.store);
    },

    setItem: function(key, item) {
      var old = this.store[key];
      if (old) {
        this.map.delete(old);
      }
      this.map.set(item, key);
      this.store[key] = item;
    },

    getItem: function(key) {
      return this.store[key];
    },

    getItems: function() {
      var items = [], store = this.store;
      for (var key in store) {
        items.push(store[key]);
      }
      return items;
    },

    ensureUniqueItem: function(idx) {
      var item = this.userArray[idx];
      var type = typeof item;
      if (type != 'object') {
        item = this.userArray[idx] = new this._primitiveTypes[type](item);
      }
      if (this.map.has(item)) {
        item = this.userArray[idx] = Polymer.Base.mixin({}, item);
      }
      return item;
    },

    _applySplices: function(splices) {
      var keySplices = [];
      for (var i=0; i<splices.length; i++) {
        var j, o, key, s = splices[i];
        // Removed keys
        var removed = [];
        for (j=0; j<s.removed.length; j++) {
          o = s.removed[j];
          key = this.remove(o);
          removed.push(key);
        }
        // Added keys
        var added = [];
        for (j=0; j<s.addedCount; j++) {
          o = this.ensureUniqueItem(s.index + j);
          key = this.add(o);
          added.push(key);
        }
        // Record splice
        keySplices.push({
          index: s.index,
          removed: removed,
          removedItems: s.removed,
          added: added
        });
      }
      return keySplices;
    }

  };

  Polymer.Collection.get = function(userArray) {
    return Polymer._collections.get(userArray) ||
      new Polymer.Collection(userArray);
  };

  Polymer.Collection.applySplices = function(userArray, splices) {
    // Only apply splices & generate keySplices if the array already has a
    // backing Collection, meaning there is an element monitoring its keys;
    // Splices that happen before the collection has been created must be
    // discarded to avoid double-entries
    var coll = Polymer._collections.get(userArray);
    return coll ? coll._applySplices(splices) : null;
  };

</script>
